# âœ… **1. Passing Data: Parent â†’ Child (Using @Input)**

### **Parent sends data â†’ Child receives it**

### ðŸ”¹ **Child Component (receiver)**

```ts
@Component({
  selector: 'child-box',
  standalone: true,
  template: `<p>Message from parent: {{ message }}</p>`
})
export class ChildBox {
  @Input() message = '';
}
```

### ðŸ”¹ **Parent Component (sender)**

```html
<child-box [message]="parentMessage"></child-box>
```

```ts
parentMessage = 'Hello Child!';
```

### âœ” Output Example:

```
Message from parent: Hello Child!
```

# âœ… **2. Passing Data: Child â†’ Parent (Using @Output + EventEmitter)**

### **Child sends event â†’ Parent listens**

### ðŸ”¹ **Child Component**

```ts
@Component({
  selector: 'child-box',
  standalone: true,
  template: `
    <button (click)="sendData()">Send to Parent</button>
  `
})
export class ChildBox {
  @Output() messageEvent = new EventEmitter<string>();

  sendData() {
    this.messageEvent.emit('Hello Parent!');
  }
}
```

---

### ðŸ”¹ **Parent Component**

```html
<child-box (messageEvent)="receiveMessage($event)"></child-box>

<p>{{ childMessage }}</p>
```

```ts
childMessage = '';

receiveMessage(msg: string) {
  this.childMessage = msg;
}
```

### âœ” Output Example:

```
Hello Parent!
```

# ðŸ”µ Summary Table

| Direction      | How?                         | Example                     |
| -------------- | ---------------------------- | --------------------------- |
| Parent â†’ Child | `@Input()`                   | `[data]="value"`            |
| Child â†’ Parent | `@Output()` + `EventEmitter` | `(event)="handler($event)"` |

---

# ðŸ”¥ BONUS: Angular 17+ (Signals Style) â€” Modern Approach

If you're using **signals**, data flows become nicer.

---

# ðŸŸ¢ Parent â†’ Child with Signals

### Parent

```ts
parentMessage = signal('Hi Child');
```

```html
<child-box [message]="parentMessage()"></child-box>
```

# ðŸŸ¡ Child â†’ Parent with Signals

### Child Component

```ts
value = signal('Child Data');

send() {
  this.dataEvent.emit(this.value());
}
```
## Shared Service for passing data between  component(not necessary Parent Child)

Here is the **simplest and best explanation** of using **RxJS Subjects** for **Parent â†” Child communication** in Angular.

This approach is used when:

âœ” Parent and child are far apart
âœ” Components are NOT directly related
âœ” You want **real-time**, **multi-level**, or **broadcast** communication
âœ” You want to avoid @Input / @Output

# ðŸš€ **Using RxJS Subject for Component Communication**

We create a **shared service** with a Subject and inject it into any component that needs to communicate.

# âœ… **1. Create a Shared Service**

```ts
import { Injectable } from '@angular/core';
import { Subject } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class MessageService {
  private messageSource = new Subject<string>();

  message$ = this.messageSource.asObservable();  // Observable

  sendMessage(msg: string) {
    this.messageSource.next(msg);
  }
}
```

### Explanation

* `Subject` = both Observable + Observer
* `message$` = components can **subscribe**
* `sendMessage` = components can **emit** messages

This is the core of Subject-based communication.

# ðŸŸ¦ **2. Child â†’ Parent using Subject**

(OR child â†’ any component)

### **Child Component**

```ts
@Component({ /* ... */ })
export class ChildComponent {
  constructor(private messageService: MessageService) {}

  sendToParent() {
    this.messageService.sendMessage('Hello from Child!');
  }
}
```

### Child HTML

```html
<button (click)="sendToParent()">Send Message</button>
```

# ðŸŸ© **3. Parent Component Listens**

```ts
@Component({ /* ... */ })
export class ParentComponent implements OnInit {
  message = '';

  constructor(private messageService: MessageService) {}

  ngOnInit() {
    this.messageService.message$.subscribe(msg => {
      this.message = msg;   // message from child
    });
  }
}
```

# âœ” Output Example

Child clicks â†’ Parent immediately receives:

```
Hello from Child!
```

# ðŸ”„ **4. Parent â†’ Child using Subject**

Just call `sendMessage` from parent.

### Parent

```ts
this.messageService.sendMessage('Hello Child!');
```

### Child

```ts
this.messageService.message$.subscribe(msg => {
  console.log(msg);
});
```

# ðŸ”¥ Why use Subject?

| When to use                             | Why?                        |
| --------------------------------------- | --------------------------- |
| Many children send data to parent       | No need for @Output in each |
| Components far apart (not parent-child) | Works anywhere              |
| Sibling components                      | Perfect                     |
| Real-time updates                       | Fast                        |
| Multiple listeners                      | Broadcast style             |

# ðŸ§  Types of Subjects

| Type                | Behavior                             |
| ------------------- | ------------------------------------ |
| **Subject**         | Sends values only after subscription |
| **BehaviorSubject** | Keeps last value, sends immediately  |
| **ReplaySubject**   | Replays last N values                |
| **AsyncSubject**    | Emits last value when completed      |

**Most commonly used for UI = BehaviorSubject**

# ðŸ“Œ BehaviorSubject Example

```ts
user = new BehaviorSubject<string>('Guest');
user$ = this.user.asObservable();
```

* Every subscriber gets the **latest value immediately**.

# ðŸ§© When NOT to use Subject?

If data is simple and only between parent-child â†’ use @Input / @Output
If it's local component state â†’ use **signals**


